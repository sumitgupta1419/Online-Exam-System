from fastapi import APIRouter, HTTPException
from datetime import datetime
from models import Answer, StudentLogin
from database import get_db

router = APIRouter(prefix="/exam", tags=["exam"])

@router.post("/student-login")
async def student_login(credentials: StudentLogin):
    """Student login with password"""
    try:
        with get_db() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                SELECT * FROM students 
                WHERE student_id = ? AND password = ?
            ''', (credentials.student_id, credentials.password))
            
            student = cursor.fetchone()
            
            if student:
                # Update connection time
                cursor.execute('''
                    UPDATE students 
                    SET connected_at = ?
                    WHERE student_id = ?
                ''', (datetime.now().isoformat(), credentials.student_id))
                conn.commit()
                
                return {
                    "success": True,
                    "message": "Login successful",
                    "student": {
                        "student_id": student['student_id'],
                        "name": student['name']
                    }
                }
            else:
                raise HTTPException(status_code=401, detail="Invalid student ID or password")
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/status")
async def get_exam_status():
    """Get current exam status"""
    try:
        with get_db() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM exam_status WHERE id = 1")
            status = cursor.fetchone()
            
            cursor.execute("SELECT COUNT(*) as count FROM questions")
            question_count = cursor.fetchone()['count']
            
            return {
                "success": True,
                "is_active": bool(status['is_active']),
                "start_time": status['start_time'],
                "duration_minutes": status['duration_minutes'],
                "total_questions": question_count
            }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/questions")
async def get_all_questions():
    """Get all exam questions (only when exam is active)"""
    try:
        with get_db() as conn:
            cursor = conn.cursor()
            
            # Check if exam is active
            cursor.execute("SELECT is_active FROM exam_status WHERE id = 1")
            status = cursor.fetchone()
            if not status or status['is_active'] == 0:
                raise HTTPException(status_code=403, detail="Exam is not active")
            
            cursor.execute("SELECT * FROM questions")
            questions = cursor.fetchall()
            
            return {
                "success": True,
                "questions": [{
                    "id": q['id'],
                    "question": q['question'],
                    "options": {
                        "A": q['option_a'],
                        "B": q['option_b'],
                        "C": q['option_c'],
                        "D": q['option_d'],
                        "E": q['option_e']
                    }
                } for q in questions]
            }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/question/{question_id}")
async def get_question(question_id: int):
    """Get a specific question by ID"""
    try:
        with get_db() as conn:
            cursor = conn.cursor()
            
            # Check if exam is active
            cursor.execute("SELECT is_active FROM exam_status WHERE id = 1")
            status = cursor.fetchone()
            if not status or status['is_active'] == 0:
                raise HTTPException(status_code=403, detail="Exam is not active")
            
            cursor.execute("SELECT * FROM questions WHERE id = ?", (question_id,))
            question = cursor.fetchone()
            
            if not question:
                raise HTTPException(status_code=404, detail="Question not found")
            
            return {
                "success": True,
                "question": {
                    "id": question['id'],
                    "question": question['question'],
                    "options": {
                        "A": question['option_a'],
                        "B": question['option_b'],
                        "C": question['option_c'],
                        "D": question['option_d'],
                        "E": question['option_e']
                    }
                }
            }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/answer")
async def submit_answer(answer: Answer):
    """Submit an answer for a question"""
    try:
        with get_db() as conn:
            cursor = conn.cursor()
            
            # Check if exam is active
            cursor.execute("SELECT is_active FROM exam_status WHERE id = 1")
            status = cursor.fetchone()
            if not status or status['is_active'] == 0:
                raise HTTPException(status_code=403, detail="Exam is not active")
            
            timestamp = datetime.now().isoformat()
            
            # Check if answer already exists
            cursor.execute('''
                SELECT id FROM answers 
                WHERE student_id = ? AND question_id = ?
            ''', (answer.student_id, answer.question_id))
            
            existing = cursor.fetchone()
            
            if existing:
                # Update existing answer
                cursor.execute('''
                    UPDATE answers 
                    SET selected_answer = ?, timestamp = ?
                    WHERE student_id = ? AND question_id = ?
                ''', (answer.selected_answer, timestamp, answer.student_id, answer.question_id))
            else:
                # Insert new answer
                cursor.execute('''
                    INSERT INTO answers (student_id, question_id, selected_answer, timestamp)
                    VALUES (?, ?, ?, ?)
                ''', (answer.student_id, answer.question_id, answer.selected_answer, timestamp))
            
            conn.commit()
            return {
                "success": True,
                "message": "Answer saved successfully"
            }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/submit")
async def submit_exam(student_id: str):
    """Submit the entire exam"""
    try:
        with get_db() as conn:
            cursor = conn.cursor()
            
            # Get student's answers
            cursor.execute('''
                SELECT question_id, selected_answer
                FROM answers
                WHERE student_id = ?
            ''', (student_id,))
            
            answers = cursor.fetchall()
            
            return {
                "success": True,
                "message": "Exam submitted successfully",
                "total_answered": len(answers),
                "student_id": student_id
            }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/my-answers/{student_id}")
async def get_my_answers(student_id: str):
    """Get all answers for a specific student"""
    try:
        with get_db() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                SELECT question_id, selected_answer
                FROM answers
                WHERE student_id = ?
            ''', (student_id,))
            
            answers = cursor.fetchall()
            
            # Convert to dictionary for easy lookup
            answer_dict = {a['question_id']: a['selected_answer'] for a in answers}
            
            return {
                "success": True,
                "answers": answer_dict
            }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
